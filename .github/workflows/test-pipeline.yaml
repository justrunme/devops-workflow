name: CI/CD Pipeline with Kind Testing

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_USERNAME: ghcr.io/${{ github.repository_owner }}
  IMAGE_TAG: ${{ github.sha }}
  KIND_CLUSTER_NAME: devops-workflow-kind-cluster

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push frontend-api Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend-api
        push: true
        load: true # Add this line to load the image into Docker daemon
        tags: ${{ env.DOCKER_USERNAME }}/devops-workflow-frontend-api:${{ env.IMAGE_TAG }}

    - name: Build and push backend-worker Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend-worker
        push: true
        load: true # Add this line to load the image into Docker daemon
        tags: ${{ env.DOCKER_USERNAME }}/devops-workflow-backend-worker:${{ env.IMAGE_TAG }}

    - name: Install Kind
      run: |
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.23.0/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind

    - name: Create Kind cluster
      run: kind create cluster --name ${{ env.KIND_CLUSTER_NAME }}

    - name: Load Docker images into Kind cluster
      run: |
        kind load docker-image ${{ env.DOCKER_USERNAME }}/devops-workflow-frontend-api:${{ env.IMAGE_TAG }} --name ${{ env.KIND_CLUSTER_NAME }}
        kind load docker-image ${{ env.DOCKER_USERNAME }}/devops-workflow-backend-worker:${{ env.IMAGE_TAG }} --name ${{ env.KIND_CLUSTER_NAME }}

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.8.0

    - name: Terraform Init
      run: terraform init
      working-directory: ./infra/terraform

    - name: Terraform Apply
      run: terraform apply -auto-approve -var="docker_username=${{ env.DOCKER_USERNAME }}" -var="image_tag=${{ env.IMAGE_TAG }}"
      working-directory: ./infra/terraform

    - name: Wait for deployments to be ready
      run: |
        kubectl wait --for=condition=available deployment/redis --timeout=300s
        kubectl wait --for=condition=available deployment/frontend-api --timeout=300s
        kubectl wait --for=condition=available deployment/backend-worker --timeout=300s

    - name: Get Frontend API NodePort
      id: get_nodeport
      run: |
        NODE_PORT=$(kubectl get service frontend-api -o jsonpath='{.spec.ports[0].nodePort}')
        echo "NODE_PORT=$NODE_PORT" >> $GITHUB_OUTPUT

    - name: Test Frontend API
      run: |
        FRONTEND_URL="http://localhost:${{ steps.get_nodeport.outputs.NODE_PORT }}"
        echo "Testing Frontend API at $FRONTEND_URL"

        # Port-forward the frontend-api service to localhost
        kubectl port-forward service/frontend-api 8080:80 & 
        PORT_FORWARD_PID=$!
        echo "Port-forwarding frontend-api to localhost:8080 (PID: $PORT_FORWARD_PID)"
        sleep 10 # Give port-forward time to establish

        # Submit markdown
        RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d '{"markdown": "# Hello from Kind!\n\nThis is a **test**."}' http://localhost:8080/convert)
        echo "Frontend API Response: $RESPONSE"
        TASK_ID=$(echo $RESPONSE | jq -r '.id')

        if [ -z "$TASK_ID" ]; then
          echo "Error: Could not get TASK_ID from frontend API response."
          exit 1
        fi
        echo "Task ID: $TASK_ID"

        # Poll for result
        MAX_ATTEMPTS=10
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          echo "Attempt $((ATTEMPT + 1)) to get result for task $TASK_ID..."
          RESULT_RESPONSE=$(curl -s http://localhost:8080/result/$TASK_ID)
          echo "Result Response: $RESULT_RESPONSE"
          STATUS=$(echo $RESULT_RESPONSE | jq -r '.status')

          if [ "$STATUS" == "completed" ]; then
            echo "Task completed successfully!"
            HTML_CONTENT=$(echo $RESULT_RESPONSE | jq -r '.html')
            if echo "$HTML_CONTENT" | grep -q "<h1>Hello from Kind!</h1>"; then
              echo "HTML content contains expected heading."
            else
              echo "Error: HTML content does not contain expected heading."
              exit 1
            fi
            if echo "$HTML_CONTENT" | grep -q "<strong>test</strong>"; then
              echo "Error: HTML content does not contain expected bold text."
              exit 1
            fi
            break
          elif [ "$STATUS" == "failed" ]; then
            echo "Task failed."
            exit 1
          fi

          ATTEMPT=$((ATTEMPT + 1))
          sleep 5
        done

        if [ "$STATUS" != "completed" ]; then
          echo "Error: Task did not complete within the expected time."
          exit 1
        fi

        # Kill port-forward process
        kill $PORT_FORWARD_PID
        echo "Port-forwarding stopped."

    - name: Cleanup Kind cluster
      if: always() # Run even if previous steps fail
      run: kind delete cluster --name ${{ env.KIND_CLUSTER_NAME }}
